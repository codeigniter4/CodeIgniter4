##########
Pagination
##########

CodeIgniter provides a very simple, but flexible pagination library that is simple to theme, works with the model,
and capable of supporting multiple paginators on a single page.

.. contents::
    :local:
    :depth: 2

*******************
Loading the Library
*******************

Like all services in CodeIgniter, it can be loaded via ``Config\Services``, though you usually will not need
to load it manually:

.. literalinclude:: pagination/001.php

.. _paginating-with-models:

**********************
Paginating with Models
**********************

In most cases, you will be using the Pager library in order to paginate results that you retrieve from the database.
When using the :doc:`Model </models/model>` class, you can use its built-in ``paginate()`` method to automatically
retrieve the current batch of results, as well as set up the Pager library so it's ready to use in your controllers.
It even reads the current page it should display from the current URL via a ``page=X`` query variable.

To provide a paginated list of users in your application, your controller's method would look something like:

.. literalinclude:: pagination/002.php

In this example, we first create a new instance of our ``UserModel``. Then we populate the data to send to the view.
The first element is the results from the database, **users**, which is retrieved for the correct page, returning
10 users per page. The second item that must be sent to the view is the Pager instance itself. As a convenience,
the Model will hold on to the instance it used and store it in the public property, ``$pager``. So, we grab
that and assign it to the ``$pager`` variable in the view.

Customizing Query for Pagination
================================

To customize a query for pagination in a model, you can add
:doc:`Query Builder <../database/query_builder>` methods before ``paginate()``
method.

Adding WHERE
------------

If you want to add WHERE conditions, you can specify conditions directly:

.. literalinclude:: pagination/003.php
    :lines: 2-

You can move the conditions to a separate method:

.. literalinclude:: pagination/017.php

.. literalinclude:: pagination/018.php
    :lines: 2-

Adding JOIN
-----------

You can join another table:

.. literalinclude:: pagination/016.php

.. important:: It is important to understand that the ``Model::paginate()`` method
    uses the **Model** and the **Query Builder** instance in the Model.
    Therefore, trying to use ``Model::paginate()`` with :ref:`db-query`
    **will not work** because ``$db->query()`` executes the query immediately
    and is not associated with the Query Builder.

If you need a complicated SQL query that you cannot write with Query Builder,
try using :ref:`db-query` and `Manual Pagination`_.

Displaying Pager Links
======================

Within the view, we then need to tell it where to display the resulting links::

    <?= $pager->links() ?>

And that's all it takes. The Pager class will render First and Last page links, as well as Next and Previous links
for any pages more than two pages on either side of the current page.

It is important to be aware that the library pattern for Next and Previous is different from what is used in the traditional way of paging results.

Next and Previous here is linked to the group of links to be displayed in the pagination structure, and not to the next or previous page of records.

If you prefer a simpler output, you can use the ``simpleLinks()`` method, which only uses "Older" and "Newer" links,
instead of the details pagination links::

    <?= $pager->simpleLinks() ?>

Behind the scenes, the library loads a view file that determines how the links are formatted, making it simple to
modify to your needs. See below for details on how to completely customize the output.

Paginating Multiple Results
===========================

If you need to provide links from two different result sets, you can pass group names to most of the pagination
methods to keep the data separate:

.. literalinclude:: pagination/004.php

Setting Page Manually
=====================

If you need to specify which page of results to return you can specify the page as the 3rd argument. This can be
handy when you have a different manner than the default ``$_GET`` variable to control which page to show.

.. literalinclude:: pagination/005.php

Specifying the URI Segment for Page
===================================

It is also possible to use a URI segment for the page number, instead of the page query parameter. Simply specify the
segment number to use as the fourth argument. URIs generated by the pager would then look
like **https://domain.tld/foo/bar/[pageNumber]** instead of **https://domain.tld/foo/bar?page=[pageNumber]**.

.. literalinclude:: pagination/006.php

Please note: ``$segment`` value cannot be greater than the number of URI segments plus 1.

*****************
Manual Pagination
*****************

You may find times where you just need to create pagination based on known data. You can create links manually
with the ``makeLinks()`` method, which takes the current page, the number of results per page, and
the total number of items as the first, second, and third parameters, respectively:

.. literalinclude:: pagination/015.php

This will, by default, display the links in the normal manner, as a series of links, but you can change the display
template used by passing in the name of the template as the fourth parameter. More details can be found in the following
sections::

    $pager->makeLinks($page, $perPage, $total, 'template_name');

It is also possible to use a URI segment for the page number, instead of the page query parameter, as described in
the previous section. Specify the segment number to use as the fifth parameter to ``makeLinks()``::

    $pager->makeLinks($page, $perPage, $total, 'template_name', $segment);

Please note: ``$segment`` value cannot be greater than the number of URI segments plus 1.

If you in need to show many pagers on one page then additional parameter which will define a group could be helpful:

.. literalinclude:: pagination/007.php

Pagination library uses **page** query parameter for HTTP queries by default (if no group or ``default`` group name given) or ``page_[groupName]`` for custom group names.

*************************************
Paginating with Only Expected Queries
*************************************

By default, all GET queries are shown in the pagination links.

For example, when accessing the URL **https://domain.tld?search=foo&order=asc&hello=i+am+here&page=2**, the page 3 link can be generated, along with the other links, as follows:

.. literalinclude:: pagination/008.php

The ``only()`` method allows you to limit this just to queries already expected:

.. literalinclude:: pagination/009.php

The *page* query is enabled by default. And ``only()`` acts in all pagination links.

*********************
Customizing the Links
*********************

View Configuration
==================

When the links are rendered out to the page, they use a view file to describe the HTML. You can easily change the view
that is used by editing **app/Config/Pager.php**:

.. literalinclude:: pagination/010.php

This setting stores the alias and :doc:`namespaced view paths </outgoing/views>` for the view that
should be used. The ``default_full`` and ``default_simple`` views are used for the ``links()`` and ``simpleLinks()``
methods, respectively. To change the way those are displayed application-wide, you could assign a new view here.

For example, say you create a new view file that works with the Foundation CSS framework, and
you place that file at **app/Views/Pagers/foundation_full.php**. Since the **application** directory is
namespaced as ``App``, and all directories underneath it map directly to segments of the namespace, you can locate
the view file through it's namespace::

    'default_full' => 'App\Views\Pagers\foundation_full'

Since it is under the standard **app/Views** directory, though, you do not need to namespace it since the
``view()`` method can locate it by filename. In that case, you can simply give the sub-directory and file name::

    'default_full' => 'Pagers/foundation_full'

Once you have created the view and set it in the configuration, it will automatically be used. You don't have to
replace the existing templates. You can create as many additional templates as you need in the configuration
file. A common situation would be needing different styles for the frontend and the backend of your application.

.. literalinclude:: pagination/011.php

Once configured, you can specify it as a the last parameter in the ``links()``, ``simpleLinks()``, and ``makeLinks()``
methods::

    <?= $pager->links('group1', 'front_full') ?>
    <?= $pager->simpleLinks('group2', 'front_full') ?>
    <?= $pager->makeLinks($page, $perPage, $total, 'front_full') ?>

Creating the View
=================

When you create a new view, you only need to create the code that is needed for creating the pagination links themselves.
You should not create unnecessary wrapping divs since it might be used in multiple places and you only limit their
usefulness. It is easiest to demonstrate creating a new view by showing you the existing ``default_full`` template:

.. literalinclude:: pagination/012.php

setSurroundCount()
------------------

In the first line, the ``setSurroundCount()`` method specifies than we want to show two links to either side of
the current page link. The only parameter that it accepts is the number of links to show.

.. note:: You must call this method first to generate correct pagination links.

hasPrevious() & hasNext()
-------------------------

These methods return a boolean ``true`` if there are more links that can be displayed on either side of the current page,
based on the value passed to `setSurroundCount()`_.

For example, let's say we have 20 pages of data. The current
page is page 3. If the surrounding count is 2, then the following links would show up like this::

    1  |  2  |  3  |  4  |  5

Since the first link displayed is page one, ``hasPrevious()`` would return ``false`` since there is no page zero. However,
``hasNext()`` would return ``true`` since there are 15 additional pages of results after page five.

getPrevious() & getNext()
-------------------------

These methods return the **URL** for the previous or next pages of results on either side of the numbered links.

For example, you have the current page set at 5 and you want to have the links before and after (the surroundCount) to be 2 each, that will give you something like this::

    3  |  4  |  5  |  6  |  7

``getPrevious()`` returns the URL for page 2. ``getNext()`` returns the URL for page 8.

If you want to get page 4 and page 6, use `getPreviousPage() & getNextPage()`_ instead.

getFirst() & getLast()
----------------------

Much like `getPrevious() & getNext()`_, these methods return the **URL** to the first and last pages in the
result set.

links()
-------

Returns an array of data about all of the numbered links. Each link's array contains the uri for the link, the
title, which is just the number, and a boolean that tells whether the link is the current/active link or not:

.. literalinclude:: pagination/013.php

In the code presented for the standard pagination structure, the methods `getPrevious() & getNext()`_ are used to obtain the links to the previous and next pagination groups respectively.

If you want to use the pagination structure where prev and next will be links to the previous and next pages based on the current page, just replace the `getPrevious() & getNext()`_ methods with `getPreviousPage() & getNextPage()`_, and the methods `hasPrevious() & hasNext()`_ by `hasPreviousPage() & hasNextPage()`_ respectively.

See following an example with these changes:

.. literalinclude:: pagination/014.php

hasPreviousPage() & hasNextPage()
---------------------------------

This method returns a boolean ``true`` if there are links to a page before and after, respectively, the current page being displayed.

For example, let's say we have 20 pages of data. The current
page is page 3. If the surrounding count is 2, then the following links would show up like this::

    1  |  2  |  3  |  4  |  5

``hasPreviousPage()`` would return ``true`` since there is page 2. And,
``hasNextPage()`` would return ``true`` since there is page 4.

.. note:: The difference to `hasPrevious() & hasNext()`_ is that they are based
    on the current page while `hasPrevious() & hasNext()`_ are based on the set
    of links to be displayed before and after the current page based on the value
    passed in `setSurroundCount()`_.

getPreviousPage() & getNextPage()
---------------------------------

These methods return a **URL** for the previous and next pages in relation to the current page being displayed.

For example, you have the current page set at 5 and you want to have the links before and after (the surroundCount) to be 2 each, that will give you something like this::

    3  |  4  |  5  |  6  |  7

``getPreviousPage()`` returns the URL for page 4. ``getNextPage()`` returns the URL for page 6.

.. note:: `getPrevious() & getNext()`_ returns the URL for the previous or next
    pages of results on either side of the numbered links.

If you want page numbers instead of URLs, you can use the following methods:

getPreviousPageNumber() & getNextPageNumber()
---------------------------------------------

These methods return the page number for the previous or next pages in relation to the current page being displayed.

getFirstPageNumber() & getLastPageNumber()
------------------------------------------

These methods return the page numbers of the first and last pages in the set of
links to be displayed. For example, if the set of links to be displayed is something like this::

    3  |  4  |  5  |  6  |  7

``getFirstPageNumber()`` will return 3 while ``getLastPageNumber()`` will return 7.    

.. note:: To obtain the page numbers of the first and last pages in the entire
    result set, you can use the following approach: The first page number is always 1, and `getPageCount()`_ can be used to
    retrieve the last page number.

getCurrentPageNumber()
----------------------

This method returns the page number of the current page.

getPageCount()
--------------

This method returns total number of pages.
